// Generated by CoffeeScript 1.10.0
(function() {
  var Cloudflare, Mailgun, Namecheap, PORT, _, app, bodyParser, crypto, db, dns, express, hash, helmet, secrets, session, tlds, whois;

  PORT = 29532;

  tlds = {
    me: 'NOT FOUND'
  };

  secrets = require('./secrets');

  _ = require('underscore');

  Namecheap = require('namecheap-api');

  Cloudflare = require('cloudflare');

  Mailgun = require('mailgun-js');

  bodyParser = require('body-parser');

  helmet = require('helmet');

  express = require('express');

  session = require('express-session');

  db = require('flat-file-db').sync('users.db');

  crypto = require('crypto');

  whois = require('whois');

  dns = require('dns');

  app = express();

  app.use(helmet());

  app.use(bodyParser.urlencoded({
    extended: false
  }));

  app.use(session({
    secret: secrets.session,
    resave: true,
    saveUninitialized: false
  }));

  app.set('view engine', 'pug');

  hash = (function(_this) {
    return function(email, pass) {
      return crypto.pbkdf2Sync(pass, email + 'gnbTSKz8XFvqSsQU5X5XQHECb6zrXzXAf8prcP8dcqy9pl3V4VRPSmoN8jV0uhy', 10000, 512, 'sha256').toString('hex');
    };
  })(this);

  app.post('/register', (function(_this) {
    return function(req, res, next) {
      var email;
      if (/[^a-z0-9\.]/i.test(req.body.uwemail)) {
        req.session.msg = {
          err: 'Invalid UW email'
        };
      } else if (req.body.uwdomain !== 'uwaterloo.ca' && req.body.uwdomain !== 'edu.uwaterloo.ca') {
        req.session.msg = {
          err: 'Invalid UW email'
        };
      } else if (req.body.pass !== req.body.confpass) {
        req.session.msg = {
          err: 'Passwords do not match'
        };
      } else if (req.body.pass.length < 8) {
        req.session.msg = {
          err: 'Password must be at least 8 chars'
        };
      } else if (/[^a-z0-9\.]/i.test(req.body.newemail)) {
        req.session.msg = {
          err: 'Invalid new email'
        };
      } else if (/[^a-z0-9]/i.test(req.body.domain)) {
        req.session.msg = {
          err: 'Invalid domain'
        };
      } else if (/[^a-z]/i.test(req.body.tld) || !tlds.hasOwnProperty(req.body.tld)) {
        req.session.msg = {
          err: 'Invalid TLD: supported tlds are ' + JSON.stringify(Object.keys(tlds))
        };
      } else {
        email = req.body.uwemail + '@' + req.body.uwdomain;
        if (db.has(email)) {
          req.session.msg = {
            err: 'UW email already used'
          };
          next();
        } else {
          dns.resolve4(req.body.domain + '.' + req.body.tld, function(err, addresses) {
            if (err) {
              return whois.lookup(req.body.domain + '.' + req.body.tld, function(err, data) {
                if (err) {
                  req.session.msg = {
                    err: 'WHOIS lookup error'
                  };
                  return next();
                } else if (data.includes(tlds[req.body.tld])) {
                  db.put(email, {
                    pass: hash(email, req.body.pass),
                    email: req.body.newemail,
                    domain: req.body.domain,
                    tld: req.body.tld
                  });
                  req.session.user = email;
                  req.session.msg = {
                    success: 'Successfully registered!'
                  };
                  return res.redirect('/manage');
                } else {
                  req.session.msg = {
                    err: 'Domain unavailable (WHOIS)'
                  };
                  return next();
                }
              });
            } else {
              req.session.msg = {
                err: 'Domain unavailable (DNS)'
              };
              return next();
            }
          });
        }
        return;
      }
      return next();
    };
  })(this));

  app.post('/login', (function(_this) {
    return function(req, res) {
      if (req.body.hasOwnProperty('email') && req.body.hasOwnProperty('pass')) {
        if (req.body.email && db.has(req.body.email) && db.get(req.body.email).pass === hash(req.body.email, req.body.pass)) {
          req.session.user = req.body.email;
          req.session.msg = {
            success: 'Successfully logged in!'
          };
          return res.redirect('/manage');
        } else {
          req.session.msg = {
            err: 'Incorrect email or password ' + hash(req.body.email, req.body.pass) + ' == ' + db.get(req.body.email).pass
          };
          return res.redirect('/login');
        }
      }
    };
  })(this));

  app.post('/manage', (function(_this) {
    return function(req, res) {
      if (req.body.logout) {
        req.session.destroy();
        return res.redirect('/login');
      }
    };
  })(this));

  app.all('/login', (function(_this) {
    return function(req, res) {
      if (db.has(req.session.user)) {
        return res.redirect('/manage');
      } else {
        res.render('login', _.extend(req.body, req.session.msg));
        return req.session.msg = {};
      }
    };
  })(this));

  app.all('/register', (function(_this) {
    return function(req, res) {
      if (db.has(req.session.user)) {
        return res.redirect('/manage');
      } else {
        res.render('register', _.extend(req.body, {
          tlds: tlds
        }, req.session.msg));
        return req.session.msg = {};
      }
    };
  })(this));

  app.all('/manage', (function(_this) {
    return function(req, res) {
      if (db.has(req.session.user)) {
        res.render('manage', req.session.msg);
        return req.session.msg = {};
      } else {
        req.session.destroy();
        return res.redirect('/login');
      }
    };
  })(this));

  app.all('*', (function(_this) {
    return function(req, res) {
      if (db.has(req.session.user)) {
        return res.redirect('/manage');
      } else {
        return res.redirect('/login');
      }
    };
  })(this));

  app.listen(PORT, 'localhost', (function(_this) {
    return function() {
      return console.log('Listening on localhost:' + PORT);
    };
  })(this));

}).call(this);
